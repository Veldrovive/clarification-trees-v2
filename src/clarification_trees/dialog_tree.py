from enum import Enum
from PIL import Image
from typing import Optional, List
from pathlib import Path

class NodeType(Enum):
    ROOT = 0  # The initial question and paired image
    CLARIFICATION_QUESTION = 1  # Question generated by clarification model
    CLARIFYING_ANSWER = 2  # Answer generated by human stand-in model
    INFERENCE = 3  # Answer generated by inference model

class DialogNode:
    node_type_to_str = {
        NodeType.ROOT: "user",
        NodeType.CLARIFICATION_QUESTION: "assistant",
        NodeType.CLARIFYING_ANSWER: "user",
        NodeType.INFERENCE: "assistant"
    }
    reverse_role_map = {
        "user": "assistant",
        "assistant": "user"
    }

    def __init__(self, node_type: NodeType, image: Optional[Image.Image], response: str):
        self.node_type = node_type
        self.image = image
        self.response = response

        self.model_name_to_message_generator = {
            "qwen-3-vl": self._to_qwen_message,
            "qwen-3-vl-2b": self._to_qwen_message,
            "qwen-3-vl-4b": self._to_qwen_message,
            "qwen-3-vl-8b": self._to_qwen_message,
            "qwen-3-vl-32b": self._to_qwen_message,
        }

    def _to_qwen_message(self, reverse_roles: bool = False):
        content = []
        if self.image is not None:
            content.append({"type": "image", "image": self.image})
        if self.response is not None and len(self.response) > 0:
            content.append({"type": "text", "text": self.response})
        assert len(content) > 0, "DialogNode must have either an image or a response"

        role = self.node_type_to_str[self.node_type]
        if reverse_roles:
            role = self.reverse_role_map[role]

        return {
            "role": role,
            "content": content
        }

    def to_message(self, model_name: str, reverse_roles: bool = False):
        return self.model_name_to_message_generator[model_name](reverse_roles)

    def to_string(self):
        string = f"{self.node_type_to_str[self.node_type]}: {self.response}"
        if self.image is not None:
            try:
                string += f" (w/ Image: {Path(self.image.filename).name})"
            except AttributeError:
                string += f" (w/ Image: {self.image})"
        return string

    def __repr__(self):
        return self.to_string()

class DialogTrajectory:
    trajectory: List[DialogNode]
    
    def __init__(self):
        self.trajectory = []  # List of DialogNode objects

    @staticmethod
    def from_dialog_tree(dialog_tree: 'DialogTree', leaf_node_idx: int):
        trajectory = DialogTrajectory()
        while leaf_node_idx != -1:
            parent_idx, node = dialog_tree.nodes[leaf_node_idx]
            trajectory.trajectory.append(node)
            leaf_node_idx = parent_idx
        return trajectory

    def to_messages(self, model_name: str, reverse_roles: bool = False):
        return [node.to_message(model_name, reverse_roles) for node in self.trajectory][::-1]

    def to_string(self):
        string = f"Trajectory of length: {len(self.trajectory)}\n"
        for node in self.trajectory[::-1]:
            string += f"\t{node.to_string()}\n"
        return string

    def __repr__(self):
        return self.to_string()

class DialogTree:
    ROOT = 0

    def __init__(
        self,
        init_question: str, init_image: Image.Image, init_image_caption: str | None = None,
        unambiguous_question: str | None = None,
        gold_answer: str | None = None, answers: List[str] | None = None
    ):
        # self.init_data = (-1, NodeType.ROOT, init_image, init_question)  # Parent index, Node type, Image, Question
        self.init_data = (-1, DialogNode(NodeType.ROOT, init_image, init_question))
        self.nodes = [self.init_data]

        self.init_image_caption = init_image_caption
        self.unambiguous_question = unambiguous_question
        self.gold_answer = gold_answer
        self.answers = answers

    def add_node(self, parent_idx: int, node_type: NodeType, image: Optional[Image.Image], response: str):
        self.nodes.append((parent_idx, DialogNode(node_type, image, response)))
        added_index = len(self.nodes) - 1
        return added_index

    def get_trajectory(self, node_idx: int):
        return DialogTrajectory.from_dialog_tree(self, node_idx)


if __name__ == "__main__":
    """
    Here we create a test tree that has the structure:
      |
     / \
    /  / \
          \
    """
    from pathlib import Path

    test_img_path = Path(__file__).parent.parent.parent / "data/clearvqa/images/train_000000.jpg"
    test_img = Image.open(test_img_path)

    tree = DialogTree("What is this?", test_img, "A cat", ["A cat", "A dog", "A person"])

    # Insert the left branch that leads to the correct answer directly
    left_branch_1 = tree.add_node(0, NodeType.CLARIFICATION_QUESTION, None, "Are you referring to the animal on the left?")
    left_branch_2 = tree.add_node(left_branch_1, NodeType.CLARIFYING_ANSWER, None, "Yes")
    left_branch_answer = tree.add_node(left_branch_2, NodeType.INFERENCE, None, "A cat")

    # Insert the right branch that further splits at the CLARIFYING_ANSWER node
    right_branch_1 = tree.add_node(0, NodeType.CLARIFICATION_QUESTION, None, "Are you referring to the animal on the right?")
    right_branch_right_2 = tree.add_node(right_branch_1, NodeType.CLARIFYING_ANSWER, None, "Yes")
    right_branch_right_3 = tree.add_node(right_branch_right_2, NodeType.CLARIFICATION_QUESTION, None, "Are you referring to a white animal?")
    right_branch_right_4 = tree.add_node(right_branch_right_3, NodeType.CLARIFYING_ANSWER, None, "Yes")
    right_branch_right_answer = tree.add_node(right_branch_right_4, NodeType.INFERENCE, None, "A dog")
    
    right_branch_left_2 = tree.add_node(right_branch_1, NodeType.CLARIFYING_ANSWER, None, "No")
    right_branch_left_answer = tree.add_node(right_branch_left_2, NodeType.INFERENCE, None, "A cat")

    # print(tree.nodes)
    
    for final_answer_node in [left_branch_answer, right_branch_right_answer, right_branch_left_answer]:
        trajectory = tree.get_trajectory(final_answer_node)
        print("\n")
        for message in trajectory.to_messages("qwen-3-vl-2b"):
            print(f"\t{message}")
